using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Enemy : MovingObject
{
    [Header("エネミーの攻撃力")] public int enemyAttackValue;
    [Header("エネミーの所持金")] public int enemyMoney;
    [Header("エネミーを倒した際の経験値")] public int experiencePoint;
    [Header("エネミーのHP")] public int enemyHp = 10;
    [Header("NPCレイヤー")] public LayerMask npcLayer;
    [HideInInspector] public string enemyName;
    [HideInInspector] public int enemyNumber;            //敵に付与される連番
    [HideInInspector] public bool isAction = false;
    [HideInInspector] public SpriteRenderer sr = null;
    private Transform target;                            //各ターンに移動しようとする目的object
    private bool isDefeatEnemy = false;

    //Startは、基本クラスの仮想Start関数をオーバーライドします。
    protected override void Start()
    {
        // Enemyオブジェクトのリストに追加して、この敵をGameManagerのインスタンスに登録します。
        //これにより、GameManagerが移動コマンドを発行できるようになります。
        //GManager.instance.AddEnemyToList(this);

        //タグを使用してPlayer GameObjectを見つけ、transformを保存します。
        target = GameObject.FindGameObjectWithTag("Player").transform;

        enemyName = "エネミー" + (enemyNumber + 1);
        sr = GetComponent<SpriteRenderer>();

        //スタート関数を抽象クラスから呼ぶ
        base.Start();
    }

    protected void Update()
    {
        if (enemyHp <= 0 && !isDefeatEnemy)
        {
            enemyDefeat();
        }
    }

    //moveEnemyは毎ターンGameMangerによって呼び出され、各敵にプレイヤーに向かって移動するように指示します。
    public void moveEnemy()
    {
        //画面内にいる場合のみ移動
        if (!sr.isVisible)
        {
            GManager.instance.enemyActionEndCount++;
            return;
        }
        isAction = true;
        int xDir = 0;
        int yDir = 0;

        //x軸がイプシロン(ほぼ)の方が大きい場合
        if (Mathf.Abs(target.position.x - transform.position.x) < float.Epsilon)
        {
            //ターゲット（プレーヤー）の位置のy座標がこの敵の位置のy座標より大きい場合は、y方向1（上に移動）を設定します。 そうでない場合は、-1に設定します（下に移動します）。
            yDir = target.position.y > transform.position.y ? 1 : -1;
        }
        //y軸が同じ場合
        else
        {
            //ターゲットのx位置が敵のx位置より大きいかどうかを確認します。そうであれば、x方向を1（右に移動）に設定し、そうでなければ-1（左に移動）に設定します。
            xDir = target.position.x > transform.position.x ? 1 : -1;
        }
        Vector2 start = transform.position;
        Vector2 next = start + new Vector2(xDir, yDir);
        RaycastHit2D hit = Physics2D.Linecast(transform.position, next, playerLayer);
        //移動先がプレイヤーの移動先と被った場合は攻撃
        if (hit.transform != null)
        {
            enemyAttack();
            return;
        }
        //移動点が他の敵と被れば移動できない
        if (checkNextPosition(next))
        {
            return;
        }
        GManager.instance.enemyNextPosition.Add(next);
        AttemptMove(xDir, yDir);
    }

    /**
     * キャラクターの移動
     */
    protected override void moveChar(Vector2 end)
    {
        RaycastHit2D hit;
        Enemy otherEnemy;
        //boxColliderを無効にして、ラインキャストがこのオブジェクト自身のコライダーに当たらないようにする。
        boxCollider.enabled = false;

        //始点から終点までラインをキャストして、blockingLayerの衝突をチェックします。(ここで自分のオブジェクトとの接触判定が出ないようにfalseしている)
        hit = Physics2D.Linecast(transform.position, end, blockingLayer | enemyLayer | playerLayer | treasureLayer | npcLayer);

        //ラインキャスト後にboxColliderを再度有効にする
        boxCollider.enabled = true;

        //何かがヒットしたかどうかを確認
        if (hit.transform == null)
        {
            //何もヒットしなかった場合は行動開始
            StartCoroutine(enemySmoothMovement(end));
            return;
        }
        //自分以外の敵を除くもの(障害物)にヒットした場合は行動できない
        if ((otherEnemy = hit.collider.GetComponent<Enemy>()) == null)
        {
            GManager.instance.enemyActionEndCount++;
            return;
        }
        bool isAbleToMove = false;
        //ヒットした敵が既に行動を終えている場合は自身も行動させない(障害物に当たって移動できない扱い)
        if (otherEnemy.isAction)
        {
            if (otherEnemy.isMoving)
            {
                isAbleToMove = true;
            }
        }
        else
        {
            //ヒットした敵が行動していない場合は自身より先に行動させる
            otherEnemy.moveEnemy();
            //行動させた敵が移動しなかった場合は自身も行動できない
            if (otherEnemy.isMoving)
            {
                isAbleToMove = true;
            }
        }
        if (!isAbleToMove)
        {
            GManager.instance.enemyActionEndCount++;
            return;
        }
        StartCoroutine(enemySmoothMovement(end));
    }

    protected IEnumerator enemySmoothMovement(Vector3 end)
    {
        yield return SmoothMovement(end);
        GManager.instance.enemyActionEndCount++;
    }

    /**
     * 敵が次の移動点に移動できるか判定(既に他の敵の先約がないかチェック)
     */
    protected bool checkNextPosition(Vector2 next)
    {
        for (int i=0;i<GManager.instance.enemyNextPosition.Count;i++)
        {
            //移動点が被った場合
            if (GManager.instance.enemyNextPosition[i] == next)
            {
                GManager.instance.enemyActionEndCount++;
                return true;
            }
        }
        return false;
    }

    /**
     * 敵の攻撃処理
     */
    protected void enemyAttack()
    {
        animator.Play("EnemyAttack");
        GManager.instance.playerHp -= enemyAttackValue;
        GManager.instance.wrightAttackLog(enemyName, GManager.instance.playerName, enemyAttackValue);
        GManager.instance.enemyActionEndCount++;
    }

    /**
     * 敵が倒された時の処理
     */
    protected void enemyDefeat()
    {
        GManager.instance.wrightDeadLog(enemyName);
        isDefeatEnemy = true;
        GManager.instance.playerMoney += enemyMoney;
        GManager.instance.beforeLevelupExperience = GManager.instance.nowExprience;
        GManager.instance.nowExprience += experiencePoint;
        GManager.instance.mostRecentExperience = experiencePoint;
        GManager.instance.removeEnemyToList(enemyNumber);
        Destroy(gameObject, 0.5f);
    }
}